
#include <stdint.h>
#include <stdio.h>

#define fives 0x55555555
#define ones  0x11111111

/* So, having used 4 bits to generate the first cut,
   we now need to show what happens when we use the next 4 bits as an extension.

   Recall that we have TWO different extensions: one with a 1 bit
   and one with 0.

    Number    occs      1st        2nd
----------------------------------------
//! 0: occurs 51 times  -48 leaves 3
//! 1:        82        -80 leaves 2
//! 2:        66        -64 leaves 2
//! 3:        35        -32 leaves 3
//! 4:        -                    14
//! 5:        -                    4
//! 6:        -                    1
//! other                          3
//!------------------------------------

//!-----------------------
//! case 0:
//!    0xyz -> xyz
//!    1y0z ->  yz so far: 2 off each of 0-3, 1 off each 4-7
//!    101x ->  2 off 5
//!    111x ->  2 off 7
 
3 off 0
3 off 3
2 off 1
4 off 5
1 off 6
3 off 7

*/

uint32_t stage3 (uint32_t w)
{
	uint32_t m1 = w & (ones << 3) & (ones << 2);
	//uint32_t m2 = w & (ones << 3) & (

	return (m1);
}


w & ((ones << 1) | ones)

/*

//!-----------------------
//! case 1:
//!         14 off 4
//!          2 off 2

    m =  w & w >> 1 & w >> 2 & one

(m & 1)<< 1 | (~m & 1) << 2

*/

uint32_t mask4 (uint32_t w)
{
	uint32_t m = w & (w >> 1) & (w >> 2) & ones;

	return (((m & ones)  << 1) | ((((~m) & ones)  << 2)));
}

 /*
0 2944237046.610016
1 2992792356.1760864
2 676246966.5408936
3 1219658508.02182
4 487863403.2087326
5 2217700591.1067963
6 877717977.3618107
7 1182328062.4826996
8 236465612.4965401
9 42038331.11049604
10 6726132.977679364
11 978346.6149351795
12 130446.21532469102
13 16054.918809192706
14 1834.8478639077296
15 195.71710548349162
16 19.571710548349138
17 1.842043345726978
18 0.16373718628684283
*/



/* thoughts:

If "1?yz" then "yz" valid or even "(1?yz -1) & 3"
If "??1x" then "(??1x -1) & 3" valid.

The above gives 0s: 2
                1s: 2+2
                2s: 2+2
                3s: 2

Generated by:
    and t1, w, ones, lsl #3      ; captures "1???" pattern
    and t2, w, ones, lsl #1      ; captures "??1?" pattern
    orr t2, t2, t1,  lsr #2      ; ands the two possibilities together in bit 1
    orr m1, t2, t2,  lsr #1      ; creates mask m1
    sub t1, w, ones              ; creates answer, but everywhere ..
    and r1, m1, t1               ;  .. masks in right places for the 12 cases
*/

uint32_t mask1 (uint32_t w)
{
	uint32_t t1 = w & (ones << 3);
	uint32_t t2 = w & (ones << 1);

	t2 = t2 | (t1 >> 2);

	return (t2 | (t2 >> 1));

	// and t,  w,  ones, lsl #3     ; captures "1???" pattern
	// and m1, w,  ones, lsl #1     ; captures "??1?" pattern
	// orr m1, m1, t,    lsr #2     ; ands the two possibilities together
	//                              ;   .. in bit 1
        // orr m1, m1, m1,  lsr #1      ; creates mask m1
}

uint32_t out1 (uint32_t w)
{
	return (mask1 (w) & (w - ones));

	// sub t, w, ones               ; creates answer, but everywhere ..
	// and r1, m1, t                ;  .. masks in right places for
	//                              ;         the 12 cases
}

/*
Four remaining cases are:
    0x0y
Need to get four answers: a 1, a 0 and two jump outs.

    rsb w', w, #0                ; creates ~w
    and t1, ones, w', lsr #3     ; bit 3 is 0
    and t2, ones, w', lsr #1     ; bit 1 is 0
    and j,  ones, w,  lsr #2     ; bit 2 is 1, and therefore jump out required
    and m2, t2, t1               ; ands the two possibilities together in bit 0
                                 ;  .. which is the mask (for just 1 bit)
    and r2, m2, w                ; creates masked result...
    sub j', ones, j              ; creates ~j     
    and r2, r2, j'               ;  .. and masks out j


If x = 0, then result is 0x0y
If x = 1, then jump out
 */

uint32_t mask2 (uint32_t w)
{
	uint32_t t1 = ones & ((~w) >> 3);
	uint32_t t2 = ones & ((~w) >> 1);
	
	return (t1 & t2);
	// alternatively: ones & ((~w) >> 3) & ((~w) >> 1)

	// rsb t, w, #0                 ; creates ~w
	// and m2, ones, t, lsr #3      ; ones & ((~w) >> 3)
	// and m2, m2,   t, lsr #1      ; ones & ((~w) >> 1)
}

uint32_t control (uint32_t w)
{
	return (mask2 (w) & ones & (w >> 2));
	// alternatively: mask2 (w) & (w >> 2)

	// ands c, m2, w, lsr #2        ; m2 & (w >> 2)
	//  ; note sets flags
}

uint32_t out2 (uint32_t w)
{
	uint32_t r = mask2 (w) & w;

	return (r);
	
	// and r2, m2, w                ; m2 & w

}

uint32_t out (uint32_t w)
{
	return (out1 (w) | out2 (w));

	// and r, r1, r2                ; r1 & r2

	// and out0, mask, r            ; mask = 0x00030003
	// and out1, mask, r, lsl #4    ; mask = 0x00030003
	// and out2, mask, r, lsl #8    ; mask = 0x00030003
	// and out3, mask, r, lsl #12   ; mask = 0x00030003

	// blne <fix-up>                ; control word is non-zero
	
	// str out0, [out], #4          ; store hi/lo 16-bit pair
	// str out1, [out], #4          ; store hi/lo 16-bit pair
	// str out2, [out], #4          ; store hi/lo 16-bit pair
	// str out3, [out], #4          ; store hi/lo 16-bit pair
	

	// totals = 12 to calculate.
	//           9 to store (+ fix-up costs)
	//               = 2.625 instructions per poisson
}





uint32_t ror (uint32_t w)
{
	return (((w & 1) << 31) | (w >> 31));
}

void print_bits (uint32_t w)
{
	uint32_t i;

	for (i = 0; i < 4; i++)
		printf("%u", (w >> (3-i)) & 1);
}

//    rsb tmp, w,   #0              ; tmp = ~w
//    and tmp, tmp, fives, lsl #1   ; tmp = (~w) & (fives << 1)
//    orr m1,  tmp, tmp,   lsr #1   ; m1 = mask1

uint32_t mask_out1 (uint32_t w)
{
	w = (~w) & (fives << 1);
	w = w | (w >> 1);

	return (w);
}

// m2 = m1

uint32_t mask_out2 (uint32_t w)
{
        w = (~w) & (fives << 1);

	return (w | w >> 1);
}

//    and tmp, w, fives, lsl #1     ; tmp = w & (fives << 1)
//    lsr t1,  w, #1                ; t1  = w << 1
//    rsb t1,  t1, #0               ; t1  = ~(w << 1)
//    and tmp, tmp, t1              ; tmp = tmp & ~(w << 1)
//    orr tmp, tmp, tmp, lsr #1     ; tmp = tmp | (tmp >> 1)
//    rsb m3, tmp, #0               ; tmp = ~tmp

uint32_t mask_out3 (uint32_t w)
{
	uint32_t t = w & (fives << 1);

	w = t & (~(w << 1));

	return (~(w | (w >> 1)));
}


uint32_t stage2 (uint32_t x, uint32_t w, uint32_t accum)
{
	uint32_t m = mask_out2 (x);

	/*printf ("     Stage 2: x = [%01u] w = [%01u] "
		"mask = [%01u] value = [%01u]\n",
		x & 3,
		w & 3,
		m & 3,
		x & w & fives & 3);*/

	return (((~m) & accum) | (m & (x & w & fives)));
}

//    add tmp, w, fives             ; tmp = w + fives
//    and tmp, m1, tmp              ; tmp = m & (w + fives)
//    rsb t2,  m1, #0               ; t2  = ~m1
//    and t2,  t2, accum            ; t2  = (~m) & accum
//    orr s1,  t2, tmp              ; s1  = result

uint32_t stage1 (uint32_t w, uint32_t accum)
{
	uint32_t m = mask_out1 (w);

	return (((~m) & accum) | (m & (w + fives)));
}

int main (void)
{
	uint32_t p;

	for (p = 0; p < 16; p++) {
		printf ("p = %01x, control = %01x, out = %01x\n",
			p,
			control (p) & 0xf,
			mask4 (p) & 0xf);
	}
	
/*	uint32_t p;
	uint32_t accum = 0xffffffff;
	uint32_t accum2;
	uint32_t x;
	uint32_t m1;
	uint32_t m2;


	for (p = 0; p < 16; p++) {
		x  = (p >> 2) & 3;
		
		m1 = mask_out1 (p);
		m2 = mask_out2 (x);
		accum2 = stage2 (x, p, accum);
		printf ("p = ");      print_bits (p);
		printf ("; m2 = "  ); print_bits (m2 & 3);
		printf ("; s2 = " );  print_bits (accum2);
		printf ("; m1 = "  ); print_bits (m1 & 3);
		printf ("; s1 = " );  print_bits (stage1 (p, accum2) & 3);
		printf ("\n");
	}*/

	return (0);
}
